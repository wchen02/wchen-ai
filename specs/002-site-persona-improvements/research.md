# Research: Site Persona Improvements

**Branch**: `002-site-persona-improvements` | **Date**: 2026-02-27

## Decision 1: Resend API Integration for Newsletter

**Decision**: Use Resend's Contacts API with Segments (formerly Audiences).

**Rationale**: Resend recently migrated from "Audiences" to "Segments." Contacts are now global entities identified by email. The flow is: `POST /contacts` with a `segments` array to assign the contact to a newsletter segment. Authentication is via Bearer token (`Authorization: Bearer re_xxx`). Rate limit is 2 req/s per team.

**Key endpoints**:
- `POST https://api.resend.com/contacts` — create contact (body: `{ email, segments: [segmentId] }`)
- `POST https://api.resend.com/emails` — send confirmation email for double opt-in

**Environment variables needed**: `RESEND_API_KEY`, `RESEND_SEGMENT_ID`

**Alternatives considered**:
- Buttondown: Good free tier but less control over the API flow.
- Mailgun mailing lists: Already used for contact form, but newsletter features are limited and would couple two distinct concerns to one provider.

## Decision 2: Double Opt-in Without Server-Side State

**Decision**: Stateless HMAC token approach — no Cloudflare KV or database required.

**Rationale**: Resend does not support native double opt-in. A typical implementation requires storing tokens server-side (e.g., in KV). However, we can avoid this by encoding the email and timestamp into an HMAC-signed URL. The verification endpoint checks the signature and expiry without any storage lookup.

**Flow**:
1. User submits email → `POST /api/newsletter`
2. Server generates: `sig = HMAC-SHA256(NEWSLETTER_SECRET, email + "|" + timestamp)`
3. Server sends confirmation email via Resend with link: `https://wchen.ai/api/newsletter-confirm?email=<email>&ts=<timestamp>&sig=<sig>`
4. User clicks link → `GET /api/newsletter-confirm`
5. Server recomputes HMAC, checks signature match + timestamp within 24h window
6. On success, server calls `POST https://api.resend.com/contacts` to add contact to segment
7. Server redirects to `/newsletter-confirmed` static page

**Environment variables needed**: `NEWSLETTER_SECRET` (random 32+ char string for HMAC signing)

**Alternatives considered**:
- Cloudflare KV for token storage: Works but adds infrastructure complexity (KV namespace, bindings). Overkill for a personal site newsletter.
- Skip double opt-in: Not GDPR-compliant and results in lower quality subscriber list.

## Decision 3: Dark Mode Toggle with Static Export

**Decision**: Class-based dark mode via Tailwind v4 `@custom-variant` + blocking inline script + localStorage.

**Rationale**: The current site uses `prefers-color-scheme` (CSS media query) for dark mode. To add a manual toggle that persists, we need:
1. Switch Tailwind to class-based dark mode: `@custom-variant dark (&:where(.dark, .dark *));`
2. Add a blocking `<script>` in `<head>` that reads localStorage and applies the `dark` class before first paint (prevents FOUC)
3. The `ThemeToggle` client component reads/writes localStorage and toggles the class
4. When no user preference exists, the script checks `window.matchMedia("(prefers-color-scheme: dark)")` as fallback

The inline script is compatible with the existing CSP (`'unsafe-inline'` is already allowed for scripts). The approach works with `output: "export"` since the script is static HTML.

**globals.css changes**:
- Remove `@media (prefers-color-scheme: dark)` CSS variable block
- Add `@custom-variant dark (&:where(.dark, .dark *));`
- Add `.dark` class selectors for CSS variables

**Alternatives considered**:
- Cookie-based: Requires server-side reading, incompatible with static export.
- CSS-only with no toggle: Already implemented, but doesn't allow manual override.

## Decision 4: Table of Contents Generation

**Decision**: Build-time heading extraction from MDX content via regex, rendered as a server component.

**Rationale**: Headings are extracted from the raw MDX content string using a regex pattern for markdown headings (`## Heading`, `### Heading`). This runs during `getWritingBySlug()` at build time. The extracted heading list (id, text, level) is passed to a `TableOfContents` server component. IDs are generated by slugifying the heading text.

The TOC is only rendered when 3+ headings are present (per spec FR-012). Heading IDs need to match what `next-mdx-remote` generates — by default, MDX does not add IDs to headings. We will add a `rehype-slug` plugin to the MDX pipeline to auto-generate heading IDs, then parse those same IDs in the extraction function.

**New dependency**: `rehype-slug` (adds `id` attributes to headings in rendered MDX)

**Alternatives considered**:
- Client-side DOM parsing: Violates no-runtime-content-fetching principle.
- rehype-toc plugin: Generates TOC within the MDX content itself, but doesn't allow separate positioning or conditional rendering.

## Decision 5: Social Icons

**Decision**: Inline SVG components — no icon library dependency.

**Rationale**: Only 3 icons needed (X/Twitter, LinkedIn, GitHub). Inline SVGs are lightweight, render crisply, and avoid adding a dependency. The SVGs will live in a `SocialIcons` component that renders the appropriate icon based on a platform key.

**Alternatives considered**:
- Lucide React: Clean icons but adds ~50KB dependency for 3 icons.
- React Icons: Large package, tree-shaking helps but still overkill.
- heroicons: Good option but still an unnecessary dependency for 3 static icons.

## Decision 6: JSON-LD Structured Data

**Decision**: Render JSON-LD as `<script type="application/ld+json">` in page components.

**Rationale**: Next.js metadata API supports JSON-LD via a script tag in the page component body (not in the metadata export). This is the recommended Next.js pattern. The Person schema goes on the about page, and Article schema goes on each writing page.

**Person schema fields**: name, url, jobTitle, sameAs (social links), image (headshot)
**Article schema fields**: headline, author, datePublished, dateModified, description, url, image

**Alternatives considered**:
- next-seo library: Adds a dependency for something achievable with a simple script tag.
- Metadata API only: Next.js metadata doesn't have a built-in JSON-LD field; the script tag approach is the official recommendation.
